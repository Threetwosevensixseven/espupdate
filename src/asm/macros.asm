; macros.asm

include "version.asm", 1                                ; Auto-generated by ..\build\cspect.bat or builddot.bat

Border                  macro(Colour)
                        if Colour=0
                          xor a
                        else
                          ld a, Colour
                        endif
                        out (ULA_PORT), a
                        if Colour=0
                          xor a
                        else
                          ld a, Colour*8
                        endif
                        ld (23624), a
mend

Freeze                  macro(Colour1, Colour2)
Loop:                   Border(Colour1)
                        Border(Colour2)
                        jr Loop
mend

CSBreak                 macro()                         ; Intended for CSpect debugging
                        push bc                         ; enabled when the -brk switch is supplied
                        noflow                          ; Mitigate the worst effect of running on real hardware
                        db $DD, $01                     ; On real Z80 or Z80N, this does NOP:LD BC, NNNN
                        nop                             ; so we set safe values for NN
                        nop                             ; and NN,
                        pop bc                          ; then we restore the value of bc we saved earlier
mend

CSExit                  macro()                         ; Intended for CSpect debugging
                        noflow                          ; enabled when the -exit switch is supplied
                        db $DD, $00                     ; This executes as NOP:NOP on real hardware
mend

PrintMsg                macro(Address)
                        ld hl, Address
                        call PrintRst16
mend

Rst8                    macro(Command)
                        rst $08
                        noflow
                        db Command
mend

ESPSendBytes            macro(BufferStart, BufferLength)
                        ld hl, BufferStart
                        ld de, BufferLength
                        call ESPSendBytesProc
mend

ESPReadReg              macro(Addr32)
                        ld hl, Addr32 and $FFFF
                        ld (SLIP.ReadRegAddr), hl
                        ld hl, Addr32 >> 16
                        ld (SLIP.ReadRegAddr+2), hl
                        ld hl, SLIP.ReadReg
                        ld de, SLIP.ReadRegLen
                        call ESPSendBytesProc
mend

NextRegRead             macro(Register)
                        ld bc, $243B
                        ld a, Register
                        out (c), a
                        inc b
                        in a, (c)
mend

WaitFrames              macro(Frames)
                        ld bc, Frames
                        call WaitFramesProc
mend

FillLDIR                macro(SourceAddr, Size, Value)
                        ld a, Value
                        ld hl, SourceAddr
                        ld (hl), a
                        ld de, SourceAddr+1
                        ld bc, Size-1
                        ldir
mend

ESPValidateCmd          macro(Op, ValWordAddr)
                        ld a, Op
                        ld hl, ValWordAddr
                        call ESPValidateCmdProc
mend

ErrorAlways             macro(ErrAddr)
                        ld hl, ErrAddr
                        jp ErrorProc
mend

ErrorIfCarry            macro(ErrAddr)
                        jp nc, Continue
                        ld hl, ErrAddr
                        jp ErrorProc
Continue:
mend

ErrorIfNoCarry          macro(ErrAddr)
                        jp c, Continue
                        ld hl, ErrAddr
                        jp ErrorProc
Continue:
mend

ErrorIfNotZero          macro(ErrAddr)
                        jp z, Continue
                        ld hl, ErrAddr
                        jp ErrorProc
Continue:
mend

PrintBufferHex          macro(Addr, Len)
                        ld hl, Addr
                        ld de, Len
                        call PrintBufferHexProc
mend

Page16kZXBank           macro(Bank, ReEnableInterrupts)
                        ld a, ($5B5C)                   ; Previous value of port
                        and $F8
                        or Bank                         ; Select bank
                        ld bc, 0x7ffd
                        di
                        ld ($5B5C), a
                        out (c), a
                        if (ReEnableInterrupts)
                          ei
                        endif
mend

MirrorA                 macro()
                        noflow
                        db $ED, $24
mend

ESPSendCmdWithData      macro(Op, DataAddr, DataLen, ErrAddr)
                        ld a, Op
                        ld de, DataAddr                 ; This can be in de because it's just as quick to pop hl later
                        ld hl, DataLen                  ; This is faster being in hl because we copy to memory
                        ld bc, ErrAddr                  ; This can be in bc because it's just as quick to pop hl later
                        ld ix, 0
                        ld (SLIP.HeaderCS), ix          ; Clears the header checksum
                        call ESPSendCmdWithDataProc
mend

ESPSendDataBlock        macro(Opcode, DataAddr, DataLen, Seq, ErrAddr)
                        ld hl, DataAddr
                        ld bc, DataLen
                        call ESPSetDataBlockProc

                        ld hl, DataLen
                        ld de, Seq
                        call ESPSetDataBlockHeaderProc

                        ld a, Opcode
                        ld de, DataAddr                 ; This can be in de because it's just as quick to pop hl later
                        ld hl, DataLen+16               ; This is faster being in hl because we copy to memory
                        ld bc, ErrAddr                  ; This can be in bc because it's just as quick to pop hl later
                        ld ix, SLIP.DataBlock
                        call ESPSendCmdWithDataProc
mend

SetUARTBaud             macro(BaudTable, BaudMsg)
                        ld hl, BaudTable
                        ld de, BaudMsg
                        call SetUARTBaudProc
mend

SafePrintStart          macro()                         ; Included at the start of every routine which calls rst 16
                        di                              ; Interrupts off while paging. Subsequent code will enable them.
                        ld (SavedStackPrint), sp        ; Save current stack to be restored in SafePrintEnd()
                        ld sp, (Return.Stack1)          ; Set stack back to what BASIC had at entry, so safe for rst 16
                        nextreg $54, 4                  ; Restore what BASIC is expecting to find at $8000 (16K bank 2)
                        nextreg $55, 5                  ; Restore what BASIC is expecting to find at $A000 (16K bank 2)
                        nextreg $56, 0                  ; Restore what BASIC is expecting to find at $C000 (16K bank 0)
                        nextreg $57, 1                  ; Restore what BASIC is expecting to find at $E000 (16K bank 0)
mend

SafePrintEnd            macro()                         ; Included at the end of every routine which calls rst 16
                        di                              ; Interrupts off while paging. Subsequent code doesn't care.
                        ld (SavedA), a                  ; Preserve A so it's completely free of side-effects
                        ld a, (DeallocateBanks.Upper1)  ; Read bank to restore at $8000
                        cp $FF                          ; If $FF we didn't allocate it yet,
                        jr z, NotUpper1                 ; so don't restore,
                        nextreg $54, a                  ; otherwise restore original bank at $8000.
NotUpper1:              ld a, (DeallocateBanks.Upper2)  ; Read bank to restore at $A000
                        cp $FF                          ; If $FF we didn't allocate it yet,
                        jr z, NotUpper2                 ; so don't restore,
                        nextreg $55, a                  ; otherwise restore original bank at $A000.
NotUpper2:              ld a, (DeallocateBanks.Upper3)  ; Read bank to restore at $C000
                        cp $FF                          ; If $FF we didn't allocate it yet,
                        jr z, NotUpper3                 ; so don't restore,
                        nextreg $56, a                  ; otherwise restore original bank at $C000.
NotUpper3:              ld a, (DeallocateBanks.Upper3)  ; Read bank to restore at $E000
                        cp $FF                          ; If $FF we didn't allocate it yet,
                        jr z, NotUpper4                 ; so don't restore,
                        nextreg $57, a                  ; otherwise restore original bank at $E000.
NotUpper4:
SavedA equ $+1:         ld a, SMC                       ; Restore A so it's completely free of side-effects
                        ld sp, (SavedStackPrint)        ; Restore stack to what it was before SafePrintStart()
mend

